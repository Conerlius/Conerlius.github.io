---
layout:     article
title:      "c++gdb"
subtitle:   " \"编译\""
date:       2021-03-16 18:00:00
author:     "Conerlius"
category: c++
keywords: c++
tags:
    - c++
---

## 大纲

- 概述
- `gdb`的安装
- 调试原理
  
## 概述

`gdb`是什么之类的，这里就不说了，看这个文章的，多多少少都知道的，简而言之就是调试的！与之差不多的还有很多，eg:`llvm`

## `gdb`的安装

本文是在`Msys2`的环境中进行的，所以这里说的是在`Msys2`中如何安装`gdb`；

使用`pacman`安装

```pacman
pacman -S gdb
```  

安装完成后，直接敲入`gdb`指令回车后可以看到类似以下的样子

![png](/images/c++/gcc_debug_1.png)


## 调试原理

这里就以`gdb`为例简述`gdb`的底层调试原理。使用一下指令生成`gdb`调试用的程序（`debug`和`release`文件的差异或在后续的文档中记录）

```gcc
g++ -g hello.cpp -o hello
```

在`g++`中的`-g`是调试时使用的参数，通过`-g`生成`gdb`需要的调试文件，如果通过`-g`生成的是汇编文件或者是机器码文件，则可以通过`strip`去直接剔除debug信息直接生成`release`版本的执行程序!

说完`debug`程序的生成后，我们看看`gdb`的一些基本原理!

`GDB调试`包括2个程序：`gdb程序`和`被调试程序`。根据这2个程序是否运行在同一台电脑中，可以把`GDB的调试`模型分为2种: 

1. 本地调试 
2. 远程调试

- 本地调试

`gdb调试程序`和`被调试程序`运行在同一台电脑中。

![png](/images/c++/gcc_debug_2.png)

远程调试：调试程序运行在一台电脑中，被调试程序运行在另一台电脑中。

![png](/images/c++/gcc_debug_3.jpeg)

RSP协议，全称是： GDB Remote Serial Protocol(GDB远程通信协议)。
它们都是字符串，有固定的开始字符('$')和结束字符('#')，最后还有两个十六进制的ASCII字符作为校验码

```
$: 开始符
s:单步指令
#：结束符
2个16进制ASCII符：校验码  ->(73)
```

`gdb`常见的指令：

| 指令 | 说明 |
|-- |--|
| run | 从头开始连续而非单步执行程序|
| next | 执行下一行语句|
| step | 执行下一行语句,如果有函数调用则进入函数|
| qiut | 退出|
|break n | 在某一行设置断点|
|delete n | 删除某一行的断点|
|enable n | 启动某一行的断点 |
|disable n | 禁用某一行的断点|
| clear|清理所有的断点|
|bt|查看各级函数调用及参数|
|set args |设置程序中变量的值|
|show args |查看程序中变量的值|
|watch|设置观察点|

以上仅仅是一部分，需要的可以自行`google`完整的！

我们以一个简单的`hello`程序为例：

```c++
#include <stdio.h>

int main(void) {
	int a = 1;
    int b = 2;
    int c = a + b;
    printf("c = %d \n", c);
    return 0;
}
```

通过以下指令可以生成这个程序的`debug`程序

```gcc
g++ -g hello.cpp -o hello
```
在正确的坏境中会生成一个`hello.exe`的文件,对可执行程序 `hello` 进行调试，输入命令：

```gdb
gdb ./hello
```

系统首先会启动gdb进程，这个进程会调用系统函数fork()来创建一个子进程，这个子进程做两件事情： 1. 调用系统函数ptrace(PTRACE_TRACEME，[其他参数])； 2. 通过`execc`来加载、执行可执行程序`hello`，那么`hello`程序就在这个子进程中开始执行了。
